//
// Created by Admin on 08.04.2024.
//

#ifndef LESSON2_ANIMAL_H
#define LESSON2_ANIMAL_H

#include <string>

/*
 Наследование - ещё одна из парадигм ООП. Она позволяет создавать новые классы на основе уже существующих.
 Наследующие классы перенимают все поля и методы базового класса, но при этом могут переопределить методы базового класса.
 В C++ наследование реализуется с помощью ключевого слова class ClassName: public BaseClassName.
 В данном случае класс Animal является базовым классом, а классы Cat и Dog являются наследующими.
 Наследование позволяет избежать дублирования кода и способствует его сокращению.
 */
class Animal {
protected: // поля и методы, объявленные в блоке protected, доступны в наследующих классах
    int age;
    std::string name;
public:
    Animal(); // конструктор по умолчанию
    Animal(int age, std::string name); // конструктор с параметрами
    virtual void play(); // метод play объявлен как виртуальный, что позволяет переопределить его в наследующих классах
    virtual void say(); // метод say объявлен как виртуальный, что позволяет переопределить его в наследующих классах
    //также существуют чисто виртуальные методы, которые не имеют реализации в базовом классе и должны быть переопределены в наследующих классах
    //их синтаксис: virtual void method() = 0;
    ~Animal() = default; // деструктор по умолчанию
    int get_age(); // метод get_age возвращает возраст животного
    int operator+(Animal other_animal); // перегрузка оператора сложения
    //перегрузка операторов позволяет изменить поведение математических операторов для пользовательских типов данных

    //Перегрузка оператора вызова функции
    //Она позволяет вызывать объекты класса как функции
    //Пример: Animal animal; animal();
    void operator()();
    /*
     Перегрузка операторов вывода в поток (<<) и ввода из потока (>>) позволяет выводить и вводить объекты класса в потоки ввода/вывода.
     Реализуется с помощью friend-функций, которые объявляются вне класса, но имеют доступ к его закрытым полям и методам.
     Поэтому когда мы определяем эти функции, то не нужно использовать ключевое слово friend и указывать класс, к которому они относятся.
     В качестве первого параметра у них передается поток ввода/вывода, а второй параметр - объект класса, который мы хотим вывести или ввести.

     Синтаксис:
     */
    friend std::ostream& operator<<(std::ostream& os, Animal& animal);
    friend std::istream& operator>>(std::istream& is, Animal& animal);
};


#endif //LESSON2_ANIMAL_H
