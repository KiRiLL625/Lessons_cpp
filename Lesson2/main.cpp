#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <unordered_map>
#include <fstream>
#include "Animal.h"
#include "Cat.h"
#include "Dog.h"

int main() {
    /*
     Ещё одна парадигма ООП - полиморфизм. Он позволяет использовать объекты производных классов через указатель или ссылку на базовый класс.
        Полиморфизм в C++ реализуется с помощью виртуальных методов. Виртуальный метод - это метод, который объявлен в базовом классе и может быть переопределён в наследующих классах.
        В данном случае мы создаём указатель на базовый класс Animal и присваиваем ему адрес объекта производного класса Cat или Dog.
     */
    std::string animal;
    std::cin >> animal; //вводим название животного
    Animal* animal_1; //указатель на базовый класс Animal
    if(animal == "cat"){ //если введено cat, то создаём объект класса Cat
        animal_1 = new Cat(); //создаём объект класса Cat (выделяя память через new)
    }
    else{
        animal_1 = new Dog(); //создаём объект класса Dog (выделяя память через new)
    }
    animal_1->say(); //вызываем метод say через указатель на базовый класс
    animal_1->play(); //вызываем метод play через указатель на базовый класс
    //В зависимости от нашего выбора эти методы будут работать по-разному для классов Cat и Dog.
    //В этом и заключается полиморфизм - один и тот же метод вызывает разные реализации в зависимости от объекта, на который он указывает.

    //пример использования оператора сложения (перегруженного)
    Animal animal1(3, "dfdfv");
    Animal animal2(5, "dvdvdfvdf");
    //складываем первое и второе животное
    animal1 + animal2;
    //std::cout << animal1.get_age(); //у первого животного теперь возраст будет равен 8
    Animal animal3;
    std::cin >> animal3;
    animal3();











    //некоторые базовые контейнеры в C++ - вектор и список
    //список - двусвязный список (вставка и удаление за константное время)
    //вектор - динамический массив (вставка и удаление за линейное время)
    //Время добавления и удаления элементов в векторе - O(n), в списке - O(1)
    //Время произвольного доступа к элементу в векторе - O(1), в списке - O(n)
    //Время удаления элемента из середины вектора - O(n), в списке - O(1)
    std::list<int> l;
    l.push_back(10);
    l.push_back(20);
    for(auto i: l){
        std::cout << i << ' ';
    }

    std::vector<int> v;
    v.push_back(10);
    v.push_back(20);
    for(auto i: v){
        std::cout << i << ' ';
    }

    //Стек - контейнер, работающий по принципу LIFO (last in, first out)
    //(последний пришёл - первый ушёл), то есть элементы добавляются и удаляются только с одного конца

    std::stack<int> s;
    s.push(10);
    s.push(20);
    s.push(30);
    while(!s.empty()){
        std::cout << s.top() << ' ';
        s.pop();
    } //выведет 30 20 10

    //Очередь - контейнер, работающий по принципу FIFO (first in, first out)
    //(первый пришёл - первый ушёл), то есть элементы добавляются с одного конца, а удаляются с другого

    std::queue<int> q;
    q.push(10);
    q.push(20);
    q.push(30);
    while(!q.empty()){
        std::cout << q.front() << ' ';
        q.pop();
    } //выведет 10 20 30
    //Вообще в очереди есть функция back(), но использовать её не рекомендуется.
    //Время добавления и удаления элементов в стеке и очереди - O(1)

    //Приоритетная очередь - контейнер, в котором элементы хранятся в отсортированном порядке
    //и при добавлении нового элемента он автоматически вставляется в нужное место
    std::priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    pq.push(5);
    while(!pq.empty()){
        std::cout << pq.top() << ' ';
        pq.pop();
    } //выведет 20 10 5
    //Время добавления и удаления элементов в приоритетной очереди - O(log n)

    //Двусторонняя очередь (дека - deque) - контейнер, в котором элементы могут добавляться и удаляться с обоих концов
    std::deque<int> d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(5);
    while(!d.empty()){
        std::cout << d.front() << ' ';
        d.pop_front();
    } //выведет 5 10 20
    //Время добавления и удаления элементов в деке - O(1)

    //Множество - контейнер, хранящий уникальные элементы в отсортированном порядке
    std::set<int> st;
    st.insert(10);
    st.insert(20);
    st.insert(10);
    for(auto i: st){
        std::cout << i << ' ';
    } //выведет 10 20
    //Время добавления и удаления элементов в множестве - O(log n)

    //Ассоциативный массив (мапа - map) - контейнер, хранящий пары ключ-значение
    std::map<std::string, int> m;
    m["qwerty"] = 123456;
    m["qwerty2"] = 43424;
    m["qwerty123"] = 5342;
    std::cout << m["qwerty"]; //выведет 123456
    //Время добавления и удаления элементов в ассоциативном массиве - O(log n)
    //Время доступа к элементу - O(log n)

    //Неупорядоченный ассоциативный массив (unordered_map) - контейнер, хранящий пары ключ-значение
    //В отличие от обычной мапы, неупорядоченный ассоциативный массив не сортирует элементы
    std::unordered_map<std::string, int> um;
    um["qwerty"] = 123456;
    um["qwerty2"] = 43424;
    um["qwerty123"] = 5342;
    std::cout << um["qwerty"]; //выведет 123456
    //Время добавления и удаления элементов в неупорядоченном ассоциативном массиве - O(1)
    //Время доступа к элементу - O(1)

    //Итераторы - объекты, позволяющие перебирать элементы контейнера
    //Существуют итераторы вперёд (forward), назад (backward), двунаправленные (bidirectional) и произвольного доступа (random access)
    //Вектор, список, стек, очередь, дека, множество, ассоциативный массив и неупорядоченный ассоциативный массив поддерживают итераторы
    std::vector<int> v1 = {1, 2, 3, 4, 5};
    for(auto it = v1.begin(); it != v1.end(); it++){
        std::cout << *it << ' ';
    } //выведет 1 2 3 4 5
    //Итераторы можно использовать для изменения элементов контейнера
    for(auto it = v1.begin(); it != v1.end(); it++){
        *it *= 2;
    }
    for(auto i: v1){
        std::cout << i << ' ';
    } //выведет 2 4 6 8 10
    //Итераторы можно использовать для удаления элементов контейнера
    for(auto it = v1.begin(); it != v1.end();){
        if(*it % 2 == 0){
            it = v1.erase(it);
        }
        else{
            it++;
        }
    }
    for(auto i: v1){
        std::cout << i << ' ';
    } //выведет 3 5
    //Итераторы можно использовать для вставки элементов в контейнер
    for(auto it = v1.begin(); it != v1.end(); it++){
        if(*it == 3){
            v1.insert(it, 4);
        }
    }
    for(auto i: v1){
        std::cout << i << ' ';
    } //выведет 4 3 4 5
    //Итераторы можно использовать для перемещения элементов в контейнере
    for(auto it = v1.begin(); it != v1.end(); it++){
        if(*it == 3){
            v1.insert(v1.begin(), 3);
            v1.erase(it);
            break;
        }
    }
    for(auto i: v1){
        std::cout << i << ' ';
    } //выведет 3 4 4 5

    //И так далее...
    //В общем, итераторы - это очень мощный инструмент, который позволяет работать с контейнерами в C++.
    //Ключевое слово auto позволяет не указывать тип итератора явно, так как компилятор сам определит его тип.
    //Ну и ещё тип итератора очень большой, поэтому его лучше не писать вручную.

    //Итераторы также используются в алгоритмах стандартной библиотеки, так как функции благодаря
    //итераторам могут работать с любым контейнером, поддерживающим итераторы.


    /*
     Try-catch - конструкция, позволяющая обрабатывать исключения.
     Исключения - это объекты, которые генерируются при возникновении ошибок в программе.
        В C++ исключения генерируются с помощью ключевого слова throw.
        Для обработки исключений используется конструкция try-catch.
        В блоке try пишется код, который может вызвать исключение.
        В блоке catch пишется код, который обрабатывает исключение.
        В блоке catch можно указать тип исключения, которое мы хотим обработать.
        Если исключение не было обработано, то программа завершится аварийно.

        Пример:
     */
    try{
        throw 10; //генерируем исключение
    }
    catch(int x){ //ловим исключение
        std::cout << "Exception: " << x << std::endl;
    }

    //В данном случае мы генерируем исключение типа int и ловим его в блоке catch.
    //Также можно генерировать исключения пользовательских типов.

    //Пример стандартного исключения при делении на ноль
    try{
        int a = 10, b = 0;
        if(b == 0){
            throw std::runtime_error("Division by zero"); //генерируем исключение
        }
        std::cout << a / b;
    }
    catch(std::runtime_error& e){ //ловим исключение
        std::cout << e.what() << std::endl;
    }
    return 0;
}
