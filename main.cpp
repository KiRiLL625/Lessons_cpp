#include <iostream> //стандартная библиотека ввода-вывода
/*
 Системные заголовочные файлы в c++ больше не имеют расширения .h
 Пользовательские заголовочные файлы имеют расширение .hpp (редко), чаще всего .h
 */
#include "Animal.h" //подключение заголовочного файла Animal.h
//для использования класса Animal

int main(){
    std::cout << "Hello, World!" << std::endl; //вывод строки "Hello, World!" в консоль
    int a;
    std::cin >> a; //ввод числа с клавиатуры
    std::cout << "You entered: " << a << std::endl; //вывод числа в консоль
    //std:endl - перевод строки (от англ. end line)
    std::string str; //объявление переменной типа string (строка) (ура, в c++ есть строки!)
    //Если <iostream> не подключен, то для строки нужно подключить библиотеку <string>
    std::cin >> str; //ввод строки с клавиатуры
    std::cout << "You entered: " << str << std::endl; //вывод строки в консоль

    //Есть несколько способов создать объект класса:
    //1. Явное указание используемого конструктора
    Animal cat1 = Animal(); //создание объекта cat1 класса Animal с помощью конструктора по умолчанию
    Animal cat2 = Animal(5, "Barsik"); //создание объекта cat2 класса Animal с помощью конструктора с параметрами
    //2. Неявное указание используемого конструктора
    Animal cat3; //создание объекта cat3 класса Animal с помощью конструктора по умолчанию
    Animal cat4(3, "Murzik"); //создание объекта cat4 класса Animal с помощью конструктора с параметрами
    //Способ 2 явно проще и удобнее, но оба способа рабочие

    //Использование функций класса
    cat1.say(); //вывод в консоль информации о cat1
    cat2.say(); //вывод в консоль информации о cat2
    cat3.say(); //вывод в консоль информации о cat3
    cat4.say(); //вывод в консоль информации о cat4

    cat1.play(); //вывод в консоль информации о том, что cat1 играет
    cat2.play(); //вывод в консоль информации о том, что cat2 играет
    //и т.д.

    //Массивы
    int arr[5]; //объявление массива из 5 элементов типа int на стеке (обычная память)
    arr[0] = 1;
    //Тут всё как обычно, ничего нового

    //Динамические массивы
    //Для выделения памяти можно всё также использовать malloc, но в c++ есть оператор new:
    int *arr2 = new int[5]; //выделение памяти под массив из 5 элементов типа int на куче (динамическая память)
    arr2[0] = 1;
    //Тут всё также, как с обычными массивами, но нужно не забыть освободить память
    //Освобождения происходит не с помощью функции free, а с помощью оператора delete:
    delete[] arr2; //освобождение памяти
    //Если выделяли память для массива, то нужно использовать delete[] (с квадратными скобками)
    //Если выделяли память для одного элемента, то нужно использовать delete (без квадратных скобок)
    return 0;
}